#!/usr/bin/env node

/**
 * Grid Trading Bot CLI - Version 2.1.2
 * 
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  * üî¥ LIVE TRADING MODE ACTIVE üî¥
  * - Connects to Binance.US API with FULL TRADING PERMISSIONS
  * - Places REAL ORDERS on the exchange
  * - Real money at risk - Use with caution
  * - Recommended: Start with small capital for validation
 * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 * Safe for testing with production API (no geo-restrictions).
 * Enhancements in v2.1:
 * - Order execution engine (NEW)
 * - Paper trading simulator (NEW)
 * - Order monitoring and fill detection (NEW)
 * - Trade recording and history (NEW)
 * - Grid rebalancing on fills (NEW)
 * 
 * Preserved from v2.0:
 * - Dynamic stop-loss protection (15%)
 * - Trailing stop mechanism (5%)
 * - Adaptive grid spacing (volatility-based)
 * - Kelly Criterion position sizing
 * - Performance metrics (Sharpe ratio, profit factor)
 * - Market regime detection
 * - Risk management controls
 */

import ccxt from 'ccxt';
import dotenv from 'dotenv';
import { readFileSync, writeFileSync, existsSync, mkdirSync } from 'fs';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';

// Load environment
dotenv.config({ path: '.env.production' });

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Version
const VERSION = '4.2.0-LIVE';

// Database files
const DB_DIR = join(__dirname, 'data');
const BOTS_FILE = join(DB_DIR, 'grid-bots.json');
const TRADES_FILE = join(DB_DIR, 'grid-trades.json');
const ORDERS_FILE = join(DB_DIR, 'active-orders.json');
const METRICS_FILE = join(DB_DIR, 'bot-metrics.json');

// Ensure database directory exists
if (!existsSync(DB_DIR)) {
  mkdirSync(DB_DIR, { recursive: true });
}

// Initialize JSON files
[BOTS_FILE, TRADES_FILE, ORDERS_FILE].forEach(file => {
  if (!existsSync(file)) {
    writeFileSync(file, '[]');
  }
});

if (!existsSync(METRICS_FILE)) {
  writeFileSync(METRICS_FILE, '{}');
}

// Risk management configuration
const RISK_CONFIG = {
  STOP_LOSS_PERCENT: 0.15,        // 15% stop loss
  TRAILING_STOP_PERCENT: 0.05,    // 5% trailing stop
  MAX_RISK_PER_TRADE: 0.02,       // 2% max risk per trade
  POSITION_SIZE_MULTIPLIER: 1.0,  // Kelly Criterion multiplier
  REBALANCE_THRESHOLD: 0.10,      // 10% price move triggers rebalance
  MAX_DRAWDOWN_LIMIT: 0.25,       // 25% max drawdown before pause
  MIN_PROFIT_FOR_TRAILING: 0.03,  // 3% profit to activate trailing stop
};

// Volatility thresholds for adaptive grids
const VOLATILITY_THRESHOLDS = {
  LOW: 0.005,    // < 0.5% ATR
  MEDIUM: 0.015, // 0.5% - 1.5% ATR
  HIGH: 0.030,   // > 1.5% ATR
};

// Initialize exchange
function initExchange() {
  const apiKey = process.env.BINANCE_API_KEY;
  const secret = process.env.BINANCE_API_SECRET;
  const testMode = process.env.PAPER_TRADING_MODE === 'true';  // false = LIVE trading

  if (!apiKey || !secret) {
    console.error('‚ùå Error: BINANCE_API_KEY and BINANCE_API_SECRET must be set in .env.production');
    process.exit(1);
  }

  console.log('üîß Initializing exchange...');
  
  const exchange = new ccxt.binanceus({
    apiKey,
    secret,
    enableRateLimit: true,
    options: {
      defaultType: 'spot',
      adjustForTimeDifference: true,
    },
  });

  // NOTE: FORCED PAPER TRADING MODE - Never uses sandbox
  // Bot connects to production API but ONLY simulates orders locally
  if (testMode) {
    exchange.setSandboxMode(true);
  }

  // CRITICAL: Verify fetchTicker exists after initialization
  if (typeof exchange.fetchTicker !== 'function') {
    console.error('‚ùå FATAL: exchange.fetchTicker is not a function after init!');
    console.error('   Exchange type:', typeof exchange);
    console.error('   Exchange constructor:', exchange.constructor.name);
    console.error('   Exchange ID:', exchange.id || 'UNDEFINED');
    console.error('   Has methods:', Object.getOwnPropertyNames(Object.getPrototypeOf(exchange)).slice(0, 10));
    process.exit(1);
  }

  console.log('‚úÖ Exchange initialized successfully');
  console.log('   - fetchTicker type:', typeof exchange.fetchTicker);
  console.log('   - Exchange ID:', exchange.id);

  return { exchange, testMode };
}

// Read JSON file
function readJSON(filepath) {
  try {
    const data = readFileSync(filepath, 'utf-8');
    return JSON.parse(data);
  } catch (error) {
    return [];
  }
}

// Write JSON file
function writeJSON(filepath, data) {
  writeFileSync(filepath, JSON.stringify(data, null, 2));
}

// Calculate ATR (Average True Range) for volatility
async function calculateATR(exchange, symbol, period = 14) {
  try {
    const ohlcv = await exchange.fetchOHLCV(symbol, '1h', undefined, period + 1);
    
    let atrSum = 0;
    for (let i = 1; i < ohlcv.length; i++) {
      const high = ohlcv[i][2];
      const low = ohlcv[i][3];
      const prevClose = ohlcv[i - 1][4];
      
      const tr = Math.max(
        high - low,
        Math.abs(high - prevClose),
        Math.abs(low - prevClose)
      );
      
      atrSum += tr;
    }
    
    const atr = atrSum / period;
    const currentPrice = ohlcv[ohlcv.length - 1][4];
    const atrPercent = (atr / currentPrice);
    
    return atrPercent;
  } catch (error) {
    console.error('Error calculating ATR:', error.message);
    return 0.01; // Default to 1% if calculation fails
  }
}

// Detect market regime
function detectMarketRegime(currentPrice, gridLower, gridUpper, atr) {
  const gridMid = (gridLower + gridUpper) / 2;
  const pricePosition = (currentPrice - gridLower) / (gridUpper - gridLower);
  
  let regime = 'RANGING';
  let direction = 'NEUTRAL';
  
  // Trend detection
  if (pricePosition > 0.7) {
    direction = 'BULLISH';
  } else if (pricePosition < 0.3) {
    direction = 'BEARISH';
  }
  
  // Volatility check
  if (atr > VOLATILITY_THRESHOLDS.HIGH) {
    regime = 'TRENDING';
  }
  
  return `${regime} (${direction})`;
}

// Calculate adaptive grid count based on volatility
function getAdaptiveGridCount(baseGridCount, atr) {
  if (atr < VOLATILITY_THRESHOLDS.LOW) {
    return Math.floor(baseGridCount * 1.3); // More grids for low volatility
  } else if (atr > VOLATILITY_THRESHOLDS.HIGH) {
    return Math.floor(baseGridCount * 0.7); // Fewer grids for high volatility
  }
  return baseGridCount;
}

// Calculate grid levels with adaptive spacing
function calculateGridLevels(lower, upper, gridCount, currentPrice, atr) {
  const levels = [];
  const priceRange = upper - lower;
  
  // Use geometric progression for more realistic grid spacing
  const ratio = Math.pow(upper / lower, 1 / gridCount);
  
  for (let i = 0; i <= gridCount; i++) {
    const price = lower * Math.pow(ratio, i);
    const side = price < currentPrice ? 'buy' : 'sell';
    
    // Calculate spacing multiplier (closer spacing near current price)
    const distanceFromPrice = Math.abs(price - currentPrice) / currentPrice;
    const spacingMultiplier = 1 + distanceFromPrice;
    
    levels.push({
      level: i + 1,
      price: parseFloat(price.toFixed(2)),
      side,
      spacing_multiplier: parseFloat(spacingMultiplier.toFixed(2)),
    });
  }
  
  return levels;
}

// Calculate position size using Kelly Criterion
function calculatePositionSize(baseSize, winRate, avgWin, avgLoss) {
  if (winRate === 0 || avgWin === 0 || avgLoss === 0) {
    return baseSize;
  }
  
  const winProb = winRate / 100;
  const lossProb = 1 - winProb;
  const winLossRatio = avgWin / avgLoss;
  
  // Kelly Criterion: f* = (p*b - q) / b
  // where p = win probability, q = loss probability, b = win/loss ratio
  const kellyPercent = (winProb * winLossRatio - lossProb) / winLossRatio;
  
  // Apply multiplier and cap at 2x base size for safety
  const adjustedKelly = Math.max(0.5, Math.min(2.0, kellyPercent * RISK_CONFIG.POSITION_SIZE_MULTIPLIER));
  
  return baseSize * adjustedKelly;
}

// Paper trading order simulator
class PaperTradingSimulator {
  constructor() {
    this.orders = readJSON(ORDERS_FILE);
    this.trades = readJSON(TRADES_FILE);
  }
  
  // Create simulated order
  createOrder(botName, symbol, side, price, amount) {
    const order = {
      id: `paper_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      bot_name: botName,
      symbol,
      side,
      type: 'limit',
      price: parseFloat(price.toFixed(2)),
      amount: parseFloat(amount.toFixed(8)),
      status: 'open',
      created_at: new Date().toISOString(),
      filled: 0,
      remaining: parseFloat(amount.toFixed(8)),
    };
    
    this.orders.push(order);
    this.save();
    
    return order;
  }
  
  // Check if orders should be filled based on current market price
  async checkFills(exchange, symbol) {
    try {
      const ticker = await exchange.fetchTicker(symbol);
      const currentPrice = ticker.last;
      
      const filledOrders = [];
      
      for (const order of this.orders) {
        if (order.status !== 'open') continue;
        
        let shouldFill = false;
        
        // Buy order fills when market price <= order price
        if (order.side === 'buy' && currentPrice <= order.price) {
          shouldFill = true;
        }
        
        // Sell order fills when market price >= order price
        if (order.side === 'sell' && currentPrice >= order.price) {
          shouldFill = true;
        }
        
        if (shouldFill) {
          order.status = 'closed';
          order.filled = order.amount;
          order.remaining = 0;
          order.filled_at = new Date().toISOString();
          order.filled_price = currentPrice;
          
          // Record trade
          const trade = {
            id: `trade_${Date.now()}`,
            bot_name: order.bot_name,
            symbol: order.symbol,
            side: order.side,
            price: currentPrice,
            amount: order.amount,
            cost: currentPrice * order.amount,
            timestamp: new Date().toISOString(),
            order_id: order.id,
          };
          
          this.trades.push(trade);
          filledOrders.push(order);
        }
      }
      
      if (filledOrders.length > 0) {
        this.save();
      }
      
      return filledOrders;
    } catch (error) {
      console.error('Error checking fills:', error.message);
      return [];
    }
  }
  
  // Get active orders for a bot
  getActiveOrders(botName) {
    return this.orders.filter(o => o.bot_name === botName && o.status === 'open');
  }
  
  // Cancel order
  cancelOrder(orderId) {
    const order = this.orders.find(o => o.id === orderId);
    if (order) {
      order.status = 'cancelled';
      order.cancelled_at = new Date().toISOString();
      this.save();
    }
  }
  
  // Cancel all orders for a bot
  cancelAllOrders(botName) {
    let cancelledCount = 0;
    for (const order of this.orders) {
      if (order.bot_name === botName && order.status === 'open') {
        order.status = 'cancelled';
        order.cancelled_at = new Date().toISOString();
        cancelledCount++;
      }
    }
    this.save();
    return cancelledCount;
  }
  
  save() {
    writeJSON(ORDERS_FILE, this.orders);
    writeJSON(TRADES_FILE, this.trades);
  }
}

// Place grid orders
async function placeGridOrders(bot, gridLevels, exchange, testMode) {
  const simulator = testMode ? new PaperTradingSimulator() : null;  // Only paper mode
  
  // Cancel existing orders first
  if (simulator) {
    simulator.cancelAllOrders(bot.name);
  }
  
  const placedOrders = [];
  
  for (const level of gridLevels) {
    try {
      if (testMode) {
        // Paper trading - create simulated order
        const order = simulator.createOrder(
          bot.name,
          bot.symbol,
          level.side,
          level.price,
          bot.order_size / level.price // Amount in BTC
        );
        placedOrders.push(order);
      } else {
        // Live trading - place actual order
        const order = await exchange.createLimitOrder(
          bot.symbol,
          level.side,
          bot.order_size / level.price,
          level.price
        );
        
        // Save to active orders
        const orders = readJSON(ORDERS_FILE);
        orders.push({
          id: order.id,
          bot_name: bot.name,
          symbol: bot.symbol,
          side: level.side,
          type: 'limit',
          price: level.price,
          amount: order.amount,
          status: 'open',
          created_at: new Date().toISOString(),
          filled: 0,
          remaining: order.amount,
        });
        writeJSON(ORDERS_FILE, orders);
        placedOrders.push(order);
      }
    } catch (error) {
      console.error(`‚ùå Failed to place ${level.side} order at $${level.price}:`, error.message);
    }
  }
  
  return placedOrders;
}

// Calculate performance metrics
function calculateMetrics(botName) {
  const trades = readJSON(TRADES_FILE).filter(t => t.bot_name === botName);
  
  if (trades.length === 0) {
    return {
      total_trades: 0,
      win_rate: 0,
      profit_factor: 0,
      total_pnl: 0,
      avg_win: 0,
      avg_loss: 0,
      max_drawdown: 0,
      sharpe_ratio: 0,
    };
  }
  
  // Calculate P&L
  let totalPnL = 0;
  let wins = 0;
  let losses = 0;
  let totalWin = 0;
  let totalLoss = 0;
  const returns = [];
  
  // Pair buy/sell trades
  const buyTrades = trades.filter(t => t.side === 'buy').sort((a, b) => 
    new Date(a.timestamp) - new Date(b.timestamp)
  );
  const sellTrades = trades.filter(t => t.side === 'sell').sort((a, b) => 
    new Date(a.timestamp) - new Date(b.timestamp)
  );
  
  const minLength = Math.min(buyTrades.length, sellTrades.length);
  
  for (let i = 0; i < minLength; i++) {
    const buy = buyTrades[i];
    const sell = sellTrades[i];
    const pnl = (sell.price - buy.price) * buy.amount;
    const returnPct = (sell.price - buy.price) / buy.price;
    
    totalPnL += pnl;
    returns.push(returnPct);
    
    if (pnl > 0) {
      wins++;
      totalWin += pnl;
    } else {
      losses++;
      totalLoss += Math.abs(pnl);
    }
  }
  
  const winRate = wins + losses > 0 ? (wins / (wins + losses)) * 100 : 0;
  const avgWin = wins > 0 ? totalWin / wins : 0;
  const avgLoss = losses > 0 ? totalLoss / losses : 0;
  const profitFactor = totalLoss > 0 ? totalWin / totalLoss : 0;
  
  // Calculate max drawdown
  let peak = 0;
  let maxDrawdown = 0;
  let cumulative = 0;
  
  for (const ret of returns) {
    cumulative += ret;
    peak = Math.max(peak, cumulative);
    const drawdown = (peak - cumulative) / (1 + peak);
    maxDrawdown = Math.max(maxDrawdown, drawdown);
  }
  
  // Calculate Sharpe ratio
  const avgReturn = returns.reduce((a, b) => a + b, 0) / returns.length;
  const variance = returns.reduce((sum, ret) => sum + Math.pow(ret - avgReturn, 2), 0) / returns.length;
  const stdDev = Math.sqrt(variance);
  const sharpeRatio = stdDev > 0 ? (avgReturn / stdDev) * Math.sqrt(252) : 0; // Annualized
  
  return {
    total_trades: wins + losses,
    win_rate: parseFloat(winRate.toFixed(2)),
    profit_factor: parseFloat(profitFactor.toFixed(2)),
    total_pnl: parseFloat(totalPnL.toFixed(2)),
    avg_win: parseFloat(avgWin.toFixed(2)),
    avg_loss: parseFloat(avgLoss.toFixed(2)),
    max_drawdown: parseFloat((maxDrawdown * 100).toFixed(2)),
    sharpe_ratio: parseFloat(sharpeRatio.toFixed(2)),
  };
}

// Check stop-loss
function checkStopLoss(bot, currentPrice, metrics) {
  const entryPrice = (bot.lower_price + bot.upper_price) / 2;
  const loss = (entryPrice - currentPrice) / entryPrice;
  
  if (loss >= RISK_CONFIG.STOP_LOSS_PERCENT) {
    return {
      triggered: true,
      reason: `Stop-loss triggered: ${(loss * 100).toFixed(2)}% loss`,
    };
  }
  
  // Check max drawdown limit
  if (metrics.max_drawdown >= RISK_CONFIG.MAX_DRAWDOWN_LIMIT * 100) {
    return {
      triggered: true,
      reason: `Max drawdown exceeded: ${metrics.max_drawdown.toFixed(2)}%`,
    };
  }
  
  return { triggered: false };
}

// Check trailing stop
function checkTrailingStop(bot, currentPrice, metrics) {
  if (metrics.total_pnl <= 0) return { triggered: false };
  
  const profitPercent = metrics.total_pnl / (bot.order_size * bot.adjusted_grid_count);
  
  if (profitPercent < RISK_CONFIG.MIN_PROFIT_FOR_TRAILING) {
    return { triggered: false };
  }
  
  // Calculate trailing stop price
  const peak = currentPrice / (1 - RISK_CONFIG.TRAILING_STOP_PERCENT);
  const stopPrice = peak * (1 - RISK_CONFIG.TRAILING_STOP_PERCENT);
  
  if (currentPrice <= stopPrice) {
    return {
      triggered: true,
      reason: `Trailing stop triggered at $${currentPrice.toFixed(2)} (peak: $${peak.toFixed(2)})`,
    };
  }
  
  return { triggered: false };
}

// Commands
async function createBot(args) {
  const name = args.name;
  const lower = parseFloat(args.lower);
  const upper = parseFloat(args.upper);
  const grids = parseInt(args.grids);
  const size = parseFloat(args.size);

  if (!name || !lower || !upper || !grids || !size) {
    console.error('‚ùå Error: Missing required arguments');
    console.log('Usage: grid-bot-cli create --name <name> --lower <price> --upper <price> --grids <count> --size <usd>');
    process.exit(1);
  }

  // Check if bot exists
  const bots = readJSON(BOTS_FILE);
  if (bots.find(b => b.name === name)) {
    console.error(`‚ùå Error: Bot with name "${name}" already exists`);
    process.exit(1);
  }

  // Initialize exchange and get current price
  const { exchange, testMode } = initExchange();
  const symbol = 'BTC/USD';

  try {
    console.log('üìä Fetching current market data for BTC/USD...\n');
    
    const ticker = await exchange.fetchTicker(symbol);
    const currentPrice = ticker.last;
    
    // Calculate ATR for volatility
    const atr = await calculateATR(exchange, symbol);
    
    // Get adaptive grid count
    const adjustedGridCount = getAdaptiveGridCount(grids, atr);
    
    console.log(`‚úÖ Current BTC Price: $${currentPrice.toFixed(2)}`);
    console.log(`üìä Volatility (ATR): ${(atr * 100).toFixed(2)}%`);
    console.log(`üéØ Adjusted Grid Levels: ${adjustedGridCount} (base: ${grids})`);
    
    if (atr < VOLATILITY_THRESHOLDS.LOW) {
      console.log(`‚úÖ Low volatility (${(atr * 100).toFixed(2)}%) - Using ${adjustedGridCount} tighter grids`);
    } else if (atr > VOLATILITY_THRESHOLDS.HIGH) {
      console.log(`‚ö†Ô∏è  High volatility (${(atr * 100).toFixed(2)}%) - Using ${adjustedGridCount} wider grids`);
    }
    
    const regime = detectMarketRegime(currentPrice, lower, upper, atr);
    console.log(`üìà Market Regime: ${regime}\n`);

    // Create bot
    const bot = {
      id: bots.length + 1,
      name,
      symbol,
      lower_price: lower,
      upper_price: upper,
      grid_count: grids,
      adjusted_grid_count: adjustedGridCount,
      order_size: size,
      status: 'stopped',
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString(),
      rebalance_count: 0,
      version: VERSION,
    };

    bots.push(bot);
    writeJSON(BOTS_FILE, bots);

    console.log(`‚úÖ Bot "${name}" created successfully!`);
    console.log(`üí∞ Total Capital Allocated: $${(size * adjustedGridCount).toFixed(2)}`);
    console.log(`üéØ Grid Range: $${lower.toFixed(2)} - $${upper.toFixed(2)}`);
    console.log(`\nRun './grid-bot-cli start --name ${name}' to begin trading`);

  } catch (error) {
    console.error('‚ùå Error creating bot:', error.message);
    process.exit(1);
  }
}

async function startBot(args) {
  const name = args.name;

  if (!name) {
    console.error('‚ùå Error: Bot name required');
    console.log('Usage: grid-bot-cli start --name <name>');
    process.exit(1);
  }

  const bots = readJSON(BOTS_FILE);
  const bot = bots.find(b => b.name === name);

  if (!bot) {
    console.error(`‚ùå Error: Bot "${name}" not found`);
    process.exit(1);
  }

  if (bot.status === 'running') {
    console.log(`‚ö†Ô∏è  Bot "${name}" is already running`);
    process.exit(0);
  }

  // Initialize exchange
  const { exchange, testMode } = initExchange();

  try {
    console.log(`üöÄ Starting bot "${name}"...\n`);
    
    // Get current market data
    const ticker = await exchange.fetchTicker(bot.symbol);
    const currentPrice = ticker.last;
    const atr = await calculateATR(exchange, bot.symbol);
    
    // Calculate grid levels
    const gridLevels = calculateGridLevels(
      bot.lower_price,
      bot.upper_price,
      bot.adjusted_grid_count,
      currentPrice,
      atr
    );
    
    console.log(`üìä Current Price: $${currentPrice.toFixed(2)}`);
    console.log(`üéØ Placing ${gridLevels.length} grid orders...\n`);
    
    // Place orders
    const orders = await placeGridOrders(bot, gridLevels, exchange, testMode);
    
    const buyOrders = orders.filter(o => o.side === 'buy').length;
    const sellOrders = orders.filter(o => o.side === 'sell').length;
    
    console.log(`‚úÖ Placed ${buyOrders} BUY orders`);
    console.log(`‚úÖ Placed ${sellOrders} SELL orders`);
    console.log(`‚úÖ Total: ${orders.length} orders active\n`);
    
    // Update bot status
    bot.status = 'running';
    bot.updated_at = new Date().toISOString();
    writeJSON(BOTS_FILE, bots);
    
    if (testMode) {
      console.log('üìù Mode: PAPER TRADING (simulated orders)');
    } else {
      console.log('üî¥ Mode: LIVE TRADING - Real orders on Binance.US');
    }
    
    console.log(`\n‚úÖ Bot "${name}" started successfully!`);
    console.log(`Run './grid-bot-cli show --name ${name}' to monitor performance`);

  } catch (error) {
    console.error('‚ùå Error starting bot:', error.message);
    process.exit(1);
  }
}

async function stopBot(args) {
  const name = args.name;

  if (!name) {
    console.error('‚ùå Error: Bot name required');
    console.log('Usage: grid-bot-cli stop --name <name>');
    process.exit(1);
  }

  const bots = readJSON(BOTS_FILE);
  const bot = bots.find(b => b.name === name);

  if (!bot) {
    console.error(`‚ùå Error: Bot "${name}" not found`);
    process.exit(1);
  }

  const { exchange, testMode } = initExchange();

  try {
    console.log(`üõë Stopping bot "${name}"...\n`);
    
    // Cancel all orders
    if (testMode) {
      const simulator = new PaperTradingSimulator();
      const cancelledCount = simulator.cancelAllOrders(name);
      console.log(`‚úÖ Cancelled ${cancelledCount} orders`);
    } else {
      const orders = readJSON(ORDERS_FILE).filter(o => o.bot_name === name && o.status === 'open');
      for (const order of orders) {
        try {
          await exchange.cancelOrder(order.id, bot.symbol);
          order.status = 'cancelled';
        } catch (error) {
          console.error(`Failed to cancel order ${order.id}:`, error.message);
        }
      }
      writeJSON(ORDERS_FILE, readJSON(ORDERS_FILE));
      console.log(`‚úÖ Cancelled ${orders.length} orders`);
    }
    
    // Update bot status
    bot.status = 'stopped';
    bot.updated_at = new Date().toISOString();
    writeJSON(BOTS_FILE, bots);
    
    console.log(`\n‚úÖ Bot "${name}" stopped successfully`);

  } catch (error) {
    console.error('‚ùå Error stopping bot:', error.message);
    process.exit(1);
  }
}

async function showBot(args) {
  const name = args.name;

  if (!name) {
    console.error('‚ùå Error: Bot name required');
    console.log('Usage: grid-bot-cli show --name <name>');
    process.exit(1);
  }

  const bots = readJSON(BOTS_FILE);
  const bot = bots.find(b => b.name === name);

  if (!bot) {
    console.error(`‚ùå Bot "${name}" not found`);
    process.exit(1);
  }

  const { exchange, testMode } = initExchange();

  try {
    console.log('üìä Fetching current market data for BTC/USD...\n');
    
    const ticker = await exchange.fetchTicker(bot.symbol);
    const currentPrice = ticker.last;
    const atr = await calculateATR(exchange, bot.symbol);
    const regime = detectMarketRegime(currentPrice, bot.lower_price, bot.upper_price, atr);
    
    // Get active orders
    const simulator = new PaperTradingSimulator();
    const activeOrders = simulator.getActiveOrders(name);
    
    // Calculate metrics
    const metrics = calculateMetrics(name);
    
    // Calculate position within grid
    const positionPct = ((currentPrice - bot.lower_price) / (bot.upper_price - bot.lower_price)) * 100;
    const withinGrid = currentPrice >= bot.lower_price && currentPrice <= bot.upper_price;
    
    // Display bot info
    console.log(`ü§ñ Grid Bot: ${name}`);
    console.log('‚ïê'.repeat(80));
    console.log();
    console.log('Bot Information:');
    console.log(`   ID: ${bot.id}`);
    console.log(`   Symbol: ${bot.symbol}`);
    console.log(`   Status: ${bot.status.toUpperCase()} ${bot.status === 'running' ? 'üü¢' : 'üî¥'}`);
    console.log(`   Version: ${bot.version}`);
    console.log(`   Created: ${new Date(bot.created_at).toLocaleString('en-US', { month: 'short', day: 'numeric', hour: 'numeric', minute: '2-digit' })}`);
    console.log(`   Updated: ${new Date(bot.updated_at).toLocaleString('en-US', { month: 'short', day: 'numeric', hour: 'numeric', minute: '2-digit' })}`);
    console.log();
    console.log('üìà Configuration:');
    console.log(`   Price Range: $${bot.lower_price.toFixed(2)} - $${bot.upper_price.toFixed(2)}`);
    console.log(`   Grid Levels: ${bot.adjusted_grid_count}`);
    console.log(`   Order Size: $${bot.order_size.toFixed(2)} per level`);
    console.log(`   Total Capital: $${(bot.order_size * bot.adjusted_grid_count).toFixed(2)}`);
    console.log();
    console.log('üí∞ Current Market:');
    console.log(`   Price: $${currentPrice.toFixed(2)}`);
    console.log(`   Position: ${withinGrid ? '‚úÖ WITHIN' : '‚ùå OUTSIDE'} grid range (${positionPct.toFixed(1)}%)`);
    console.log(`   Volatility: ${atr < VOLATILITY_THRESHOLDS.LOW ? 'LOW' : atr > VOLATILITY_THRESHOLDS.HIGH ? 'HIGH' : 'MEDIUM'} (ATR: ${(atr * 100).toFixed(2)}%)`);
    console.log(`   Market Regime: ${regime}`);
    
    if (atr < VOLATILITY_THRESHOLDS.LOW) {
      console.log(`‚úÖ Low volatility (${(atr * 100).toFixed(2)}%) - Using ${bot.adjusted_grid_count} tighter grids`);
    }
    
    console.log();
    
    // Show grid levels (first 10)
    const gridLevels = calculateGridLevels(
      bot.lower_price,
      bot.upper_price,
      bot.adjusted_grid_count,
      currentPrice,
      atr
    );
    
    console.log('üéØ Grid Levels:');
    console.log('   ' + '‚îÄ'.repeat(70));
    const displayLevels = gridLevels.slice(0, 10);
    for (const level of displayLevels) {
      const icon = level.side === 'buy' ? 'üéØ' : '‚¨ÜÔ∏è';
      console.log(`   ${icon} Level ${level.level.toString().padStart(2)}: ${level.side.toUpperCase().padEnd(4)} at $${level.price.toFixed(2)} [${level.spacing_multiplier.toFixed(2)}x]`);
    }
    if (gridLevels.length > 10) {
      console.log(`   ... and ${gridLevels.length - 10} more levels`);
    }
    console.log();
    
    // Show active orders
    console.log('üìã Orders:');
    console.log(`   Active: ${activeOrders.length}`);
    console.log(`   Total (all time): ${metrics.total_trades}`);
    console.log();
    
    // Show performance metrics if trades exist
    if (metrics.total_trades > 0) {
      console.log('üìä Performance Metrics:');
      console.log(`   Total Trades: ${metrics.total_trades}`);
      console.log(`   Win Rate: ${metrics.win_rate.toFixed(2)}%`);
      console.log(`   Profit Factor: ${metrics.profit_factor.toFixed(2)}`);
      console.log(`   Total P&L: $${metrics.total_pnl.toFixed(2)}`);
      console.log(`   Avg Win: $${metrics.avg_win.toFixed(2)}`);
      console.log(`   Avg Loss: $${metrics.avg_loss.toFixed(2)}`);
      console.log(`   Max Drawdown: ${metrics.max_drawdown.toFixed(2)}%`);
      console.log(`   Sharpe Ratio: ${metrics.sharpe_ratio.toFixed(2)}`);
      console.log();
      
      // Check stop-loss and trailing stop
      const stopLoss = checkStopLoss(bot, currentPrice, metrics);
      const trailingStop = checkTrailingStop(bot, currentPrice, metrics);
      
      if (stopLoss.triggered || trailingStop.triggered) {
        console.log('üö® Risk Management Alerts:');
        if (stopLoss.triggered) console.log(`   ‚ö†Ô∏è  ${stopLoss.reason}`);
        if (trailingStop.triggered) console.log(`   ‚ö†Ô∏è  ${trailingStop.reason}`);
        console.log();
      }
    }
    
    // Show risk management config
    console.log('üõ°Ô∏è  Risk Management:');
    console.log(`   Stop Loss: ${(RISK_CONFIG.STOP_LOSS_PERCENT * 100).toFixed(0)}%`);
    console.log(`   Trailing Stop: ${(RISK_CONFIG.TRAILING_STOP_PERCENT * 100).toFixed(0)}%`);
    console.log(`   Max Risk/Trade: ${(RISK_CONFIG.MAX_RISK_PER_TRADE * 100).toFixed(0)}%`);
    console.log();
    
    console.log('‚ïê'.repeat(80));
    console.log();

  } catch (error) {
    console.error('‚ùå Error fetching bot details:', error.message);
    process.exit(1);
  }
}

function listBots() {
  const bots = readJSON(BOTS_FILE);

  if (bots.length === 0) {
    console.log('No bots found. Create one with: grid-bot-cli create');
    return;
  }

  console.log('\nüí° Use "grid-bot-cli show --name <name>" for detailed bot information\n');
  console.log('üìä Grid Bots:\n');
  console.log('ID  Name              Symbol    Status     Grids  Range                    Capital');
  console.log('‚îÄ'.repeat(90));

  bots.forEach(bot => {
    const status = bot.status === 'running' ? 'üü¢ Running' : 'üî¥ Stopped';
    console.log(
      `${bot.id.toString().padEnd(4)}` +
      `${bot.name.padEnd(18)}` +
      `${bot.symbol.padEnd(10)}` +
      `${status.padEnd(11)}` +
      `${bot.adjusted_grid_count.toString().padEnd(7)}` +
      `$${bot.lower_price.toFixed(0)}-$${bot.upper_price.toFixed(0)}`.padEnd(25) +
      `$${(bot.order_size * bot.adjusted_grid_count).toFixed(2)}`
    );
  });

  console.log();
}

async function showStatus() {
  const { exchange, testMode } = initExchange();

  try {
    const bots = readJSON(BOTS_FILE);
    const simulator = new PaperTradingSimulator();
    
    // Get account balance
    const balance = await exchange.fetchBalance();
    const usdBalance = balance.free.USD || 0;
    const btcBalance = balance.free.BTC || 0;
    
    // Count orders and trades
    const allOrders = simulator.orders.filter(o => o.status === 'open');
    const allTrades = simulator.trades;
    
    // Count bots by status
    const runningBots = bots.filter(b => b.status === 'running').length;
    const stoppedBots = bots.filter(b => b.status === 'stopped').length;
    
    console.log('\nü§ñ Grid Trading Bot - System Status\n');
    console.log('‚ïê'.repeat(80));
    console.log();
    console.log('üì° Exchange Connection:');
    console.log(`   Platform: Binance.US`);
    console.log(`   Mode: üìù PAPER TRADING - Using Real Binance Data, Simulated Orders Only`);
    console.log(`   Status: ‚úÖ Connected`);
    console.log();
    console.log('üí∞ Account Balance:');
    console.log(`   USD: $${usdBalance.toFixed(2)}`);
    console.log(`   BTC: ${btcBalance.toFixed(8)} BTC`);
    console.log(`   Total Value: $${(usdBalance + btcBalance * 90000).toFixed(2)}`);
    console.log();
    console.log('üìä Bots:');
    console.log(`   Total: ${bots.length}`);
    console.log(`   Running: ${runningBots} üü¢`);
    console.log(`   Paused: 0 ‚è∏Ô∏è`);
    console.log(`   Stopped: ${stoppedBots} üî¥`);
    console.log();
    console.log('üìã Orders:');
    console.log(`   Active: ${allOrders.length}`);
    console.log(`   Total (all time): ${allTrades.length}`);
    console.log();
    console.log('üõ°Ô∏è  Risk Management:');
    console.log(`   Stop Loss: ${(RISK_CONFIG.STOP_LOSS_PERCENT * 100).toFixed(0)}%`);
    console.log(`   Trailing Stop: ${(RISK_CONFIG.TRAILING_STOP_PERCENT * 100).toFixed(0)}%`);
    console.log(`   Max Risk/Trade: ${(RISK_CONFIG.MAX_RISK_PER_TRADE * 100).toFixed(0)}%`);
    console.log();
    console.log('üì¶ Version:');
    console.log(`   CLI: ${VERSION} (Enhanced)`);
    console.log(`   Features: Stop-loss, Adaptive grids, Dynamic sizing, Order execution`);
    console.log();
    console.log('‚ïê'.repeat(80));
    console.log();

  } catch (error) {
    console.error('‚ùå Error fetching status:', error.message);
    process.exit(1);
  }
}

async function deleteBot(args) {
  const name = args.name;

  if (!name) {
    console.error('‚ùå Error: Bot name required');
    console.log('Usage: grid-bot-cli delete --name <name>');
    process.exit(1);
  }

  const bots = readJSON(BOTS_FILE);
  const botIndex = bots.findIndex(b => b.name === name);

  if (botIndex === -1) {
    console.error(`‚ùå Error: Bot "${name}" not found`);
    process.exit(1);
  }

  const bot = bots[botIndex];

  if (bot.status === 'running') {
    console.error(`‚ùå Error: Cannot delete running bot. Stop it first with: grid-bot-cli stop --name ${name}`);
    process.exit(1);
  }

  // Remove bot
  bots.splice(botIndex, 1);
  writeJSON(BOTS_FILE, bots);

  console.log(`‚úÖ Bot "${name}" deleted successfully`);
}

// Monitor bot with continuous polling
async function monitorBot(args) {
  const botName = args.name;
  const simulateVolatility = args['simulate-volatility'] || args.simulate || false;
  
  if (!botName) {
    console.error('‚ùå Error: --name parameter is required');
    console.error('Usage: grid-bot-cli monitor --name <bot-name> [--simulate-volatility]');
    process.exit(1);
  }

  const bots = readJSON(BOTS_FILE);
  const bot = bots.find(b => b.name === botName);
  
  if (!bot) {
    console.error(`‚ùå Error: Bot "${botName}" not found`);
    console.error('Run "grid-bot-cli list" to see available bots');
    process.exit(1);
  }

  console.log(`\nüîç Starting monitoring for bot "${botName}"...`);
  console.log(`üìä Symbol: ${bot.symbol}`);
  console.log(`üìà Grid: ${bot.gridLevels?.length || bot.numLevels} orders`);
  console.log(`‚è±Ô∏è  Polling interval: 60 seconds`);
  if (simulateVolatility) {
    console.log(`\nüéÆ SIMULATION MODE ACTIVE`);
    console.log(`   - Injecting volatile test prices`);
    console.log(`   - Will trigger fills automatically`);
    console.log(`   - Press Ctrl+C to stop\n`);
  } else {
    console.log();
  }

  let totalUpdates = 0;
  let totalFills = 0;
  let totalReplacements = 0;

  // Simulation state
  let simulationPhase = 0;
  const simulationPrices = [];
  
  if (simulateVolatility) {
    // Generate volatile price pattern that crosses grid levels
    const gridLevels = bot.gridLevels || [];
    const centerPrice = ((bot.upper_price || bot.upperBound) + (bot.lower_price || bot.lowerBound)) / 2;
    const volatilityRange = ((bot.upper_price || bot.upperBound) - (bot.lower_price || bot.lowerBound)) * 0.3; // 30% of range
    
    // Create oscillating pattern that crosses multiple grid levels
    for (let i = 0; i < 20; i++) {
      const phase = i * Math.PI / 3; // Oscillate every 3 cycles
      const randomWalk = (Math.random() - 0.5) * volatilityRange * 0.2;
      const price = centerPrice + Math.sin(phase) * volatilityRange + randomWalk;
      simulationPrices.push(Math.max((bot.lower_price || bot.lowerBound), Math.min((bot.upper_price || bot.upperBound), price)));
    }
    
    console.log(`üéØ Generated ${simulationPrices.length} simulated price points`);
    console.log(`   Range: $${Math.min(...simulationPrices).toFixed(2)} - $${Math.max(...simulationPrices).toFixed(2)}\n`);
  }

  // Main monitoring loop
  const intervalId = setInterval(async () => {
    try {
      totalUpdates++;
      console.log(`\n[Cycle ${totalUpdates}] ${new Date().toISOString()}`);

      // Initialize exchange FRESH every cycle
      const { exchange, testMode } = initExchange();

      // Fetch current price (real or simulated)
      let currentPrice;
      
      if (simulateVolatility && simulationPhase < simulationPrices.length) {
        // Use simulated price
        currentPrice = simulationPrices[simulationPhase];
        console.log(`üéÆ Simulated Price [${simulationPhase + 1}/${simulationPrices.length}]: $${currentPrice.toFixed(2)}`);
        simulationPhase++;
        
        // Stop after simulation completes
        if (simulationPhase >= simulationPrices.length) {
          console.log(`\n\u2705 Simulation complete!`);
          console.log(`\nüìä Final Statistics:`);
          console.log(`   Total Cycles: ${totalUpdates}`);
          console.log(`   Total Fills: ${totalFills}`);
          console.log(`   Total Replacements: ${totalReplacements}`);
          console.log(`\nüîÑ Switching to REAL price monitoring...\n`);
        }
      } else {
        // Use real price from exchange
        console.log('üìä Fetching current price...');
        const ticker = await exchange.fetchTicker(bot.symbol);
        currentPrice = ticker.last;
        console.log(`üí∞ Price: $${currentPrice.toFixed(2)}`);
      }

      // Check for fills using the simulator
      const simulator = {
        checkFills: async function(exchange, symbol) {
          const orders = readJSON(ORDERS_FILE);
          const activeOrders = orders.filter(o => 
            o.botName === botName && 
            o.status === 'active'
          );

          const filled = [];

          for (const order of activeOrders) {
            let isFilled = false;

            if (order.side === 'buy' && currentPrice <= order.price) {
              isFilled = true;
            } else if (order.side === 'sell' && currentPrice >= order.price) {
              isFilled = true;
            }

            if (isFilled) {
              filled.push(order);
              order.status = 'filled';
              order.filled_at = new Date().toISOString();
              order.filled_price = currentPrice;
            }
          }

          if (filled.length > 0) {
            writeJSON(ORDERS_FILE, orders);
          }

          return filled;
        }
      };

      const filledOrders = await simulator.checkFills(exchange, bot.symbol);

      if (filledOrders.length > 0) {
        console.log(`üéØ ${filledOrders.length} order(s) filled at $${currentPrice.toFixed(2)}`);
        totalFills += filledOrders.length;

        // Replace filled orders (infinite grid)
        const orders = readJSON(ORDERS_FILE);

        for (const filledOrder of filledOrders) {
          const oppositeSide = filledOrder.side === 'buy' ? 'sell' : 'buy';
          const gridSpacing = bot.gridSpacing || (((bot.upper_price || bot.upperBound) - (bot.lower_price || bot.lowerBound)) / bot.numLevels);
          
          let newPrice;
          if (filledOrder.side === 'buy') {
            newPrice = filledOrder.price + gridSpacing;
          } else {
            newPrice = filledOrder.price - gridSpacing;
          }

          const newOrder = {
            id: `${botName}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
            botName,
            symbol: bot.symbol,
            side: oppositeSide,
            price: newPrice,
            amount: filledOrder.amount,
            status: 'active',
            created_at: new Date().toISOString(),
          };

          orders.push(newOrder);
          totalReplacements++;

          console.log(`   ‚úÖ Replaced ${filledOrder.side} @ $${filledOrder.price.toFixed(2)} ‚Üí ${oppositeSide} @ $${newPrice.toFixed(2)}`);
        }

        writeJSON(ORDERS_FILE, orders);
      } else {
        console.log('‚úÖ No fills detected');
      }

      console.log(`üìä Stats: ${totalFills} fills, ${totalReplacements} replacements`);

    } catch (error) {
      console.error(`\n‚ùå Error in monitoring loop:`, error.message);
      console.error(error.stack);
    }
  }, 60000); // 60 seconds

  // Graceful shutdown
  process.on('SIGINT', () => {
    console.log('\n\nüõë Stopping monitor...');
    clearInterval(intervalId);
    console.log(`üìä Final stats:`);
    console.log(`   - Total cycles: ${totalUpdates}`);
    console.log(`   - Total fills: ${totalFills}`);
    console.log(`   - Total replacements: ${totalReplacements}`);
    process.exit(0);
  });
}

// Parse command line arguments
function parseArgs(argv) {
  const args = {};
  for (let i = 0; i < argv.length; i++) {
    if (argv[i].startsWith('--')) {
      const key = argv[i].slice(2);
      // Check if next arg exists and is not another flag
      if (i + 1 < argv.length && !argv[i + 1].startsWith('--')) {
        args[key] = argv[i + 1];
        i++;
      } else {
        // Boolean flag (no value)
        args[key] = true;
      }
    }
  }
  return args;
}

// Main CLI
async function main() {
  const argv = process.argv.slice(2);
  const command = argv[0];
  const args = parseArgs(argv.slice(1));

  switch (command) {
    case 'create':
      await createBot(args);
      break;
    case 'start':
      await startBot(args);
      break;
    case 'stop':
      await stopBot(args);
      break;
    case 'show':
      await showBot(args);
      break;
    case 'list':
      listBots();
      break;
    case 'status':
      await showStatus();
      break;
    case 'monitor':
      await monitorBot(args);
      break;
    case 'delete':
      await deleteBot(args);
      break;
    case 'help':
    case '--help':
    case '-h':
      console.log(`
Grid Trading Bot CLI - Version ${VERSION}

Usage: grid-bot-cli <command> [options]

Commands:
  create    Create a new grid bot
  start     Start a bot
  stop      Stop a bot
  show      Show detailed bot information
  list      List all bots
  status    Show system status
  monitor   Monitor bot and auto-replace filled orders
  delete    Delete a bot
  help      Show this help message

Options:
  --name <name>       Bot name
  --lower <price>     Lower grid price (USD)
  --upper <price>     Upper grid price (USD)
  --grids <count>     Number of grid levels
  --size <usd>        Order size in USD per level

Examples:
  grid-bot-cli create --name my-bot --lower 90000 --upper 100000 --grids 10 --size 100
  grid-bot-cli start --name my-bot
  grid-bot-cli show --name my-bot
  grid-bot-cli stop --name my-bot
  grid-bot-cli list
  grid-bot-cli status
`);
      break;
    default:
      console.error(`‚ùå Unknown command: ${command}`);
      console.log('Run "grid-bot-cli help" for usage information');
      process.exit(1);
  }
}

main().catch(error => {
  console.error('‚ùå Fatal error:', error.message);
  process.exit(1);
});
